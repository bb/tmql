=== Properties ===

The tmql4j engine contains a property handler to change different properties to control the processing  The property handler is encapsulate by the runtime container and can access by specific methods of the runtime interface. Please note that duration of validity of property changes are limited to the runtime container instance. Every changes are removed if the runtime container is destroyed or a new runtime container is created, so it is possible to create two different runtime containers with different processing behaviour. 

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
-------------------------------------

=====================================
The code line explain the way to access the property handler of a specific runtime container instance. As we can see, the runtime contains a method 'getProperties' returning a reference of the internal property handler.
=====================================

All properties are handle by a property handler instance. The handler provides methods to change properties in an easy way. Please note that the handler will throw an exception if the property key is unknown. The next sub-sections explaining the supported properties and their possible values.

==== the tuple-sequence class ====

The property 'tuple-sequence-class' representing the full qualified name of the tuple sequence implementation class. This class is used to create new tuple sequences of the specified type during the whole interpretation process. The given class has to implement the abstract interface 'ITupleSequence' defined by the tmql4j engine. As base implementations the engine provides two implementations of the interface representing sequences handling new content in a different way. 

The first implementation 'UniqueTupleSequence' represents a tuple sequence only containing a tuple one times. Please note that the current draft of the topic maps query language specifies that each tuple can be contained multiple times in a tuple sequence during the querying process and as results. Related to some business use cases this behaviour isn't intend. But complex conjunctions or disjunctions using to extract specific informations from the underlying datastore can be it can be result in multiple representations of the same information item. The unique tuple sequence change this behaviour and only contains each information item one times. Please note that during the querying process an information item can contained multiple times and will be reduced after finishing the interpretation step. The reduction at the end of interpretation task is preferred because of a lower execution time. The other implementation 'MultipleTupleSequence' represents a sequence containing tuples multiple times like it is defined in the current draft. The default value of this property is the unique tuple sequence implementation.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.TUPLE_SEQUENCE_CLASS, MultipleTupleSequence.class.getName());
-------------------------------------

=====================================
The code snippet changes the tuple sequence class property to the multiple tuple sequence implementation. The change a property the methd 'put()' must be used with a key-value pair of the property to change. The supported keys are stored in the property handler and can access in a constant way. As value we use the full qualified name of the class by calling the 'getName()' method of the class object.
=====================================

==== canonizer implementation class ====

The property 'canonizer-implementation-class' representing the full qualified name of the canonizer implementation class. The class has to implements the abstract interface 'ICanonizer' and represent the canonizer implementation used to reduce the non-canonical parts of the topic maps query language expression to their canonical representations using term substitution. The tmql4j engine provides a base implementation of the canonizer interface called 'TMQLCanonizer' which reduce the all shortcut productions of the current draft by their correct canonical forms.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.CANONIZER_IMPLEMENTATION_CLASS, TMQLCanonizer.class.getName());
-------------------------------------

=====================================
The code example contains a example explaining how to change the property value of the property 'canonizer-implementation-class' the a new canonizer class name. The example changes the default value to the class 'TMQLCanonizer' by using the full qualified name of this class object. Please note, that the default value is the same like the full qualified name of 'TMQLCanonizer'.
=====================================

==== screener implementation class ====

The property 'screener-implementation-class' representing the full qualified name of the implementation class of the screener module of the engine. The screener module removes all comments and line breaks from the given query and results in a new string-represented TMQL query containing only one line. The value of the property is represented by the full qualified name of a class implementing the abstract interface 'IScreener'. As default the engine contains a base implementation of the screener interface called 'TMQLScreener'.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.SCREENER_IMPLEMENTATION_CLASS, TMQLScreener.class.getName());
-------------------------------------

=====================================
In line 3 we change the current value of the property to the full qualified name of the class 'TMQLScreener'. The property change will be affected in next execution steps of the runtime, by initializing an instance of this screener implementation during the pre-processing step. Please note that the default value is also the full qualified name of the class 'TMQLScreener'.
=====================================

==== whitespacer implementation class ====

The property 'whitespacer-implementation-class' representing the full qualified name of the white spacer implementation. A whitespacer is a special module changing the number and position of whitespaces contained in the screened query. The whitespacer adds new whitespaces which are defined as optional by the current draft but will be useful for lexical scanning. If the number of whitespaces is more than one, they will be reduced. The value of this property has to implements the abstract interface 'IWhiteSpacer'. As default the engine contains a simple whitespacer implementation 'TMQLWhiteSpacer'.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.WHITESPACER_IMPLEMENTATION_CLASS, TMQLWhiteSpacer.class.getName());
-------------------------------------

=====================================
As we see in line 3 the property is represented by a constant string contained by the property handler. The value will be changed to the qualified name of the 'TMQLWhitespacer' class. Please note that the qualified name of 'TMQLWhiteSpacer' is the default value too.
=====================================

==== lexer implementation class ====

The property 'lexer-implementation-class' representing the full qualified name of the lexical scanner implementation class. The lexical scanner is one of the core modules of the tmql4j engine, like every language processing engines. The class has to implement the abstract interface 'ILexer' and tokenize the cleaned query to language-specific tokens. Each token will be representet by an enumeration value describing the type of token. The default implementation of the 'ILexer' interface is the 'TMQLLexer'.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.LEXER_IMPLEMENTATION_CLASS, TMQLLexer.class.getName());
-------------------------------------

=====================================
In line 3 the value of the property will be changed to the full qualified name of the class 'TMQLLexer'. The class name will be used to instantiate the lexical scanner during the querying process.
=====================================

==== parser implementation class ====

The property 'parser-implementation-class' representing the full qualified name of the language parser of the tmql engine. The parser class has to implement the 'IParser' interface and transforms the stream of lexical and language-specific tokens to a tree-represented structure of the given query. The tree-representation will be used to interpret and handle the query in next execution steps. The base implementation of the 'IParser' is the class 'TMQLParser' which is used as default value of this property.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.PARSER_IMPLEMENTATION_CLASS, TMQLParser.class.getName());
-------------------------------------

=====================================
In line 3 the constant 'PARSER_IMPLEMENTATION_CLASS' is used to change the value if the 'parser-implementation-class' property to the full qualified name of the 'TMQLParser' class.
=====================================

==== result processor implementation class ====

The property 'result-processor-implementation-class' representing the full qualified name of the last important module implementation of the tmql4j engine. The result processor transform the sequences generating by the interpretation moduls to an iterable result representation. The result processor class has to implements the abstract interface 'IResultProcessor' or extends from the base implementation 'ResultProcessingImpl' which is used as default value of this property.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.RESULTPROCESSOR_IMPLEMENTATION_CLASS, ResultProcessorImpl.class.getName());
-------------------------------------

=====================================
In line 3 the property value is changed to the full qualified name of the class 'ResultProcessorImpl' as new result processor of the engine processing chain.
=====================================

==== result set implementation class ====

The result processor transform the tuple sequences provided by the interpreter modules to a JDBC like representation of a result set. A result set is a two-dimensional representation of the querying results and contains a set of results representing the origin tuples of the sequence. 

The implementation of the result set and the result can be changed to. The result processor using the property 'result-set-implementation-class' to create a new instance of the class identified by the value of this property. The class has to implements the interface 'IResultSet'. As default the engine provides different implementations for each result type - XTM, CTM or TMAPI.

The result implementation class will be provided by the result set class using the method 'getResultClass()' or the type parameter 'T'. Please note that there is also an property 'result-tuple-implementation-class' which can be used by own implementations of result set to switch result types. Normally this property will not used.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3: 	property.put(TMQLRuntimeProperties.RESULT_SET_IMPLEMENTATION_CLASS, SimpleResultSet.class.getName());
-------------------------------------

=====================================
The short code snippet show a simple way to change the result set class using the full qualified name of the favoured result set implementation as you can see in line 3.
=====================================

====  type transitivity ====

As specified in the current topic maps query language draft all type relations can be handled transitive or non-transitive. The transitivity will be respected by the supertype-subtype index and the type-instance index. The tmql4j engine uses the transitivity characteristics as fundamental property of navigation interpretation of optional types. The current draft of TMQL contains two definitions of transitivity in different contexts.

=====================================
Accordingly, for transitivity a TMQL processor will assume that if a concept B is a supertype of A, and C is a supertype of B, then also C is a supertype of A. A processor will also interpret such relation as reflexive so that every type is a subtype and a supertype of itself. 
=====================================

=====================================
For the binary relation between an instance and a type the interpretation and representation in topic maps data model is adopted. Accordingly, a processor will assume that if a concept is an instance of a type C, that very concept is also an instance of all supertypes of C. 
=====================================

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.TMDM_TYPE_TRANSITIVITY, false);
-------------------------------------

=====================================
In line 3 the property handler is used to disable the type transitivity characteristics of the tmql4j engine.
=====================================

Please note that there is another possibility to change the transitivity characteristics. The draft specifies a pragma definition contained by the environment clause to change the transitivity of the type-hierarchy. This changes will only be respected for this one query.

-------------------------------------
1:	%pragam taxonometry tm:intransitive
-------------------------------------

/////////////////////////////////////////////////////////////
==== topic maps modification language extension ====

In addition to the draft of the 15th august of 2008 the tmql4j engine also supports a language extension containing new productions realizing a modification part of the topic maps query language. The grammar of the new productions are explained in upper chapters and wont be a part of this section. 

The property 'enable-tmql-language-extension-tmql-ul' enables or disables the support of the language extension containing the modification part of the language. If the extension is disabled it is not allowed to use any modification expression within the given query otherwise an exception will be thrown by the parsing processor.

Please not that the allowed expression described in the section <<allowed_expressions>> and this property are different.

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.ENABLE_TMQL_LANGUAGE_EXTENSION_TMQL_UL, false);
4:
5:	property.enableLanguageExtensionTmqlUl(false);
-------------------------------------

=====================================
In line 3 the property handler is used to disable the modification language extension of the tmql4j engine. The method in line 5 has the same effect than the line number 3.
=====================================
/////////////////////////////////////////////////////////////


==== materialize-meta-model ====

The current draft of the topic maps query language contains the a predefined environment containing all predefined types of the topic maps data model. To query all name items or all associations of the type supertype-subtype the engine checks if the meta model topic items are contained by the given topic map. If the topics are not contained, the engine will create it to realize the execution of the given query. The engine adds the meta model topics to the given topic map only if the property 'materialize-meta-model' is set to the value true, otherwise it will add this topics to the environment map created during the initialization step. 

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.put(TMQLRuntimeProperties.MATERIALIZE_META_MODEL, false);
-------------------------------------

==== use-multiple-threads ====

The system property enables the usage of multiple threads to run some expression faster than as single-threaded expression. The property represented by the string constant 'use-multiple-threads'. 

-------------------------------------
1:	TMQLRuntimeProperties property = runtime.getProperties();
2:
3:	property.useMultipleThreads(false);
-------------------------------------

